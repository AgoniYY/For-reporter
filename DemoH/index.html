<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
		
	</head>
	<body>
		
	</body>
	<script type="text/javascript">
		// 冒泡排序
		// function bubblesort(arr) {
		// 	var i = 0,j = 0;
		// 	for(i = 1;i < arr.length;i++){
		// 		for(j = 0;j <= arr.length-i;j++){
		// 			var temp = 0;
		// 			if(arr[j]>arr[j+1]){
		// 				temp = arr[j];
		// 				arr[j] = arr[j+1];
		// 				arr[j+1] = temp;
		// 			}
		// 		}
		// 	}
		// }
		// qwer = [19,21,32,13,44];
		// bubblesort(qwer);
		// console.log(qwer);
		// console.log(qwer.reverse());


		//二路归并
		//将两个按值有序序列合并成一个按值有序序列,则称之为二路归并排序
		// 		function merge(left, right) {
		// 			var result = [],
		// 				il = 0,
		// 				ir = 0;
		// 
		// 			while (il < left.length && ir < right.length) {
		// 				if (left[il] < right[ir]) {
		// 					result.push(left[il++]);
		// 				} else {
		// 					result.push(right[ir++]);
		// 				}
		// 			}
		// 			while(left[il]){
		// 				result.push(left[il++]);
		// 			}
		// 			while(right[ir]){
		// 				result.push(right[ir++]);
		// 			}
		// 			return result;
		// 		}
		// 		var ii = [13,2,3,1,5];
		// 		var oo = [213,3,2,1];
		// 		console.log(merge(ii, oo))


		//字符珠串操作
		// 1.判断回文字符串
		// function palindrome(str) {
		// 	// \W匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
		// 	var re = /[\W_]/g;
		// 	// 将字符串变成小写字符,并干掉除字母数字外的字符
		// 	var lowRegStr = str.toLiwberCase().replace(re, '');
		// 	// 如果字符串lowRegStr的length长度为0时，字符串即是palindrome
		// 	if (lowRegStr.length === 0) {
		// 		return true;
		// 	}
		// 	// 如果字符串的第一个和最后一个字符不相同，那么字符串就不是palindrome
		// 	if (lowRegStr[0] != lowRegStr[lowRegStr.length - 1]) {
		// 			return false;
		// 		}
		// 		//递归
		// 		return palindrome(lowRegStr.slice(1, lowRegStr.length - 1));
		// 	}
		
		
		// 配合模糊效果生成验证码(生成指定长度的随机字符串)
		// function randomString(n) {
		// 	var str = 'abcdefghijklmnopqrstuvwxyz0123456789';
		// 	var tmp = '';
		// 	for(var i = 0;i < n;i++){
		// 		tmp +=str.charAt(Math.round(Math.random() * str.length));
		// 	}
		// 	return tmp;
		// }
		// 
		// console.log(randomString(4))
		
		
		// 统计字符串中册书最多的字母
		// 利用Object中key的唯一性,利用key来进行筛选,然后计数
		// function findmaxDupllicateChar(str) {
		// 	if(str.length == 1) {
		// 		return str;
		// 	}
		// 	var charobj = {};
		// 	for(var i = 0; i < str.length; i++) {
		// 		if(!charobj[str.charAt(i)]) {
		// 			charobj[str.charAt(i)] = 1;
		// 		} else {
		// 			charobj[str.charAt(i)] += 1;
		// 		}
		// 	}
		// 	var maxChar = '', maxValue = 1;
		// 	for(var k in charobj) {
		// 		if(charobj[k] >= maxValue) {
		// 			maxChar = k;
		// 			maxValue = charobj[k];
		// 		}
		// 	}
		// 	return maxChar + ': ' + maxValue;
		// }
		// 
		// var a = 'ajsahfhasjkfhjkaashdjhakjsdkja';
		// console.log(findmaxDupllicateChar(a))
		
		
		//数组去重
		//利用object中的key的唯一性,利用key来进行筛选
		// function unique(arr) {
		// 	var obj = {};
		// 	var data = [];
		// 	for (var i in arr) {
		// 		if(!obj[arr[i]]){
		// 			obj[arr[i]] = true;
		// 			data.push(arr[i]);
		// 		}
		// 	}
		// 	return data;
		// }
		// var a = [1,1,1,2,3,4,2,3];
		// console.log(unique(a))
		
		//numver数组中最大差值
		// function getMaxProfit(arr) {
		// 	var min = arr[0], max = arr[0];
		// 	for(var i = 0; i < arr.length; i++) {
		// 		if(arr[i] < min) {
		// 			min = arr[i];
		// 		}
		// 		if(arr[i] > max){
		// 			max = arr[i];
		// 		}
		// 	}
		// 	return max - min;
		// }
		// var a = [1,3,2,4,1,5,1,2,3,1]
		// console.log(getMaxProfit(a))
		
		//阶乘
		//1.非递归实现
		// function factorialize(num) {
		// 	var result = 1;
		// 	if(num < 0){
		// 		return -1;
		// 	}
		// 	if(num == 0 || num == 1){
		// 		return 1;
		// 	}
		// 	while(num > 1){
		// 		result *= num--;
		// 	}
		// 	return result;
		// }
		// var io = 3;
		// console.log(factorialize(io))
		
		// 2.递归实现
		// function factorialize(num) {
		// 	var result = 1;
		// 	if(num < 0){
		// 		return -1;
		// 	}
		// 	if(num == 0 || num == -1){
		// 		return 1;
		// 	}
		// 	if(num > 1){
		// 		return  result = num * factorialize(num-1)
		// 	}
		// 	return result;
		// }
		// var pp = 3;
		// console.log(factorialize(pp))
		
		// 斐波那契数列
		// 简约非递归实现
		// function getFibonacci(n) {
		// 	var fibarr = [];
		// 	var i = 0;
		// 	while(i < n) {
		// 		if(i <= 1){
		// 			fibarr.push(i);
		// 		}else{
		// 			fibarr.push(fibarr[i - 1] + fibarr[i - 2])
		// 		}
		// 		i++;
		// 	}
		// 	return fibarr;
		// }
		// var a = 6;
		// console.log(getFibonacci(a))
		
		//强行递归实现
		// function getfib(n) {
		// 	if(n == 0){
		// 		return 0;
		// 	}
		// 	if(n == 1){
		// 		return 1;
		// 	}
		// 	if(n > 1){
		// 		return getfib(n - 1) + getfib(n - 2);
		// 	}
		// }
		// function fibo(len) {
		// 	var fibo = [];
		// 	for(var i = 0; i < len; i++){
		// 		fibo.push(getfib(i))
		// 	}
		// 	return fibo;
		// }
		// var b = 4;
		// console.log(fibo(4))
		
		
		// 二分查找:是在序数组中用的比较频繁的一种算法,优点是次数比较少,查找速度快,平均性能好;缺点是要求待查表为有序,且插入删除困难
		// 非递归实现
		// function binary_search(arr, key) {
		// 	var low = 0,
		// 	high = arr.length - 1;
		// 	while(low <= high){
		// 		var mid = parseInt((high + low) / 2);
		// 		if(key == arr[mid]) {
		// 			return mid;
		// 		}else if(key > arr[mid]){
		// 			low = mid + 1;
		// 		}else if(key < arr[mid]){
		// 			high = mid - 1;
		// 		}
		// 	}
		// 	return -1;
		// }
		// var a = [1,2,3,4,5,6];
		// // var b = ;
		// console.log(binary_search(a, 3))
		
		//递归实现
		function binary_search2(arr, low, high, key) {
			if(low > high) {
				return low;
			}
			var mid = parseInt((low + high) / 2);
			if(key == arr[mid]){
				return mid;
			}else if(key > arr[mid]){
				return binary_search2(arr, mid+1, high, key);
			}else if(key < arr[mid]){
				return binary_search2(arr, low, mid-1, key);
			}
		}
		var a = [1,2,3,4,5];
		console.log(binary_search2(a, 1, 3, 2));
		
		
		
		// var Arr = [3, 5, 6, 7, 9, 12, 15];
		// function binary(find, arr, low, high) {
		// 	if (low <= high) {
		// 		if (arr[low] == find) {
		// 			return low;
		// 		}
		// 		if (arr[high] == find) {
		// 			return high;
		// 		}
		// 		var mid = Math.ceil((high + low) / 2);
		// 		if (arr[mid] == find) {
		// 			return mid;
		// 		} else if (arr[mid] > find) {
		// 			return binary(find, arr, low, mid - 1);
		// 		} else {
		// 			return binary(find, arr, mid + 1, high);
		// 		}
		// 	}
		// 	return -1;
		// }
		// binary(15, Arr, 0, Arr.length - 1);
	</script>
</html>